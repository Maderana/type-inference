{
  "name": "Type-inference",
  "tagline": "The Hindley Milner Type Inference Algorithm",
  "body": "Hindley Milner Type Inference\r\n===\r\n\r\n[![Build Status](https://travis-ci.org/prakhar1989/type-inference.svg?branch=master)](https://travis-ci.org/prakhar1989/type-inference)\r\n\r\nThe [Hindley Milner Type Inference](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system) or Algorithm W is a type-inference algorithm that infers types in a programming language.\r\n\r\nThis repository contains a working implementation written in OCaml to demonstrate type-inference on a small functional language.\r\n\r\n### Demo\r\n\r\n<a href=\"https://asciinema.org/a/c0w60mlj35keg24cvkfbj1z86?&speed=3&theme=tango&autoplay=1\"><img src=\"https://asciinema.org/a/c0w60mlj35keg24cvkfbj1z86.png\" width=\"636\"/></a>\r\n\r\n\r\n### Î»-calculus\r\n\r\nThe language that this implementation works on is a small subset called the [lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus). In essence, the lambda calculus allows one to express any computation purely in terms of anonymous functions and application of these functions.\r\n```ocaml\r\n> (fun x -> x * x)          (* function declaration *)\r\n> (fun x -> x * x) 10       (* function application *)\r\n```\r\nIn pure lambda calculus, [numerals](https://en.wikipedia.org/wiki/Church_encoding#Church_numerals) and [booleans](https://en.wikipedia.org/wiki/Church_encoding#Church_Booleans) are also expressed in terms of functions but to make it easy, the language supports integer and boolean literals, alongwith binary operations such as addition, multiplication, boolean and etc.\r\n\r\n##### Types\r\n\r\nBefore we jump on to the type-inference algorithm, we need to define the types in our language. There are three primitive types that our language supports -\r\n\r\n- `int`: An integer type for integer literals. Binary operations such as `+` and `*`, work only on integers and return an integer type.\r\n- `bool`: Our language has boolean literals `true` and `false`, both of which have a `bool` type. To operate on bools `&&` and `||` are provided. Lastly, two additional operators `>` and `<` work on any type, but return a bool type.\r\n- `T -> U`: The function type where the `T` is the type of the input and `U` is the return type of the function. So for example, a square function above has a type `int -> int`.\r\n\r\n### REPL\r\nThe project ships with an interactive Read-Eval-Print-Loop (REPL) that you can use to play with the algorithm. To build the REPL, you need OCaml installed. \r\n\r\nIf you prefer [Docker](https://www.docker.com/), there's an image that you can use to try out the REPL. Simply run\r\n```shell\r\n$ docker run -w /home/opam/type-inference -it prakhar1989/type-infer /bin/bash\r\n```\r\n\r\nCompile the REPL with `make` and if all goes well, you should be good to go. \r\n```\r\n$ ./repl\r\n\r\nWelcome to the REPL.\r\nType in expressions and let Hindley-Milner Type Inference run its magic.\r\n\r\nOut of ideas? Try out a simple lambda expression: (fun x -> x + 10)\r\n\r\n> 10 + 20 > 40\r\nbool\r\n> (fun x -> (x && true) || false)\r\n(bool -> bool)\r\n> (fun x -> x + 10) 20\r\nint\r\n> (fun f -> f 3)\r\n((int -> 'a) -> 'a)\r\n>  (fun f -> (fun g -> (fun x -> f (g x))))\r\n(('a -> 'b) -> (('c -> 'a) -> ('c -> 'b)))\r\n```\r\n\r\n### Tests\r\n\r\nTo run the tests, you need [Alcotest](https://github.com/mirage/alcotest) package installed. Install it by running `opam install alcotest`.\r\n\r\n```\r\n$ make test\r\n```\r\n\r\n### Thanks\r\nHuge thanks to these [lecture notes](http://www.cs.cornell.edu/courses/cs3110/2011sp/lectures/lec26-type-inference/type-inference.htm) for providing an understandable breakdown of the algorithm.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}